# Урок 36. Менедж команды. Менедж команды приложений. Кастомные менедж команды.

## Менедж команды и настройки.

Менедж команды в рамках Django это возможность запустить скрипт из консоли, для выполнения абсолютно различных действий.

Существует три способа запуска менедж команды

```
django-admin <command> [options]
python manage.py <command> [options]
python -m django <command> [options]
```

В случае запуска через `django-admin` вы можете указать какой файл настроек использовать при помощи опции `--settings`.

Если вы запускаете команду через `manage.py` (самый распространенный способ) файл настроек будет выбран в соответствии с
самим файлом `manage.py` (Напоминаю структуру, информация о файле настроек для Django проекта находится именно в
файле `manage.py`)

Мы использовали некоторые команды, но давайте посмотрим подробнее.

## Доступные команды.

![](https://www.meme-arsenal.com/memes/d4d5ed953c6b783bc97f142cb8e89d4d.jpg)

### Check

```
python manage.py check [app_label [app_label ...]]
```

Например

```
django-admin check auth admin myapp
```

Команда для запуска проверки кода на качество (например, что неправильно указаны аргументы модели, или некорректно
указано свойство для класса админки, итд. список огромный)
Посмотреть базовый список проверок можно [Тут](https://docs.djangoproject.com/en/3.1/ref/checks/)

### makemessages

```
python manage.py makemessages
```

Командна для работы с переводами(локализацией) сайтов.

Команда проходит через весь код и ищет места которое заготовлены для перевода (Для python кода, это везде где вы
используете метод `gettext`, для шаблонов везде где используется темплейт тег `translate`,
подробнее [Тут](https://docs.djangoproject.com/en/3.1/topics/i18n/translation/))

Создаёт\Обновляет файлы в которых хранятся\будут храниться переводы текста на друге языки. Принимает параметры `--all`
, `--extension`, `--locale`, `--exclude`, `--domain`, `--ignore` итд.

Подробности использования
параметров [тут](https://docs.djangoproject.com/en/3.1/ref/django-admin/#django-admin-makemessages)

Обсудим основные.

`--locale LOCALE, -l LOCALE` нужно, что бы указать на какой язык планируется перевод (на самом деле повлияет только на то,
как будет называться файл с переводами, и как этот перевод будет называться в системе), например для французского можно
назвать файл `fr`, для итальянского `it` итд.

```
django-admin makemessages --locale=pt_BR
django-admin makemessages --locale=pt_BR --locale=fr
django-admin makemessages -l pt_BR
django-admin makemessages -l pt_BR -l fr
```

`--ignore PATTERN` - Игнорировать (не искать) переводы в определённых местах, например `--ignore *.py' - игнорировать
все python файлы.

Создаст файлы с расширением `.po` и списком всех мест где нужно будет указать перевод

```
#. Translators: This message appears on the home page only
# path/to/python/file.py:123
msgid "Welcome to my site."
msgstr ""
```

Комментом указано, откуда конкретно взят текст для перевода, ниже сам текст который нужно перевести, и место где мы
можем указать перевод.

### compilemessages

Компилирует файлы для переводов.

Делает из `.po` файлов `.mo` файлы. Django принимает именно `.mo` как файлы откуда брать перевод.

Поддерживает указание локали и игнор, подробнее в доке.

### createcachedtable

Создаёт таблицу для кеша в базе данных, подробно рассматривали на занятии по сессиям и кешам.

### shell

Уже известная вам команда `shell` открывает интерактивную `python` консоль, с уже импортированными библиотеками вашего
проекта, например Django.

### dbshell

По аналогии со знакомой нам командой `shell` открывает консоль со всеми необходимыми импортированными данными, но для
базы данных.

Например, для postgres, откроется `psql` итд.

### diffsettings

Команда, которая покажет чем, отличается ваш файл `settings.py` от оригинала.

### dumpdata

Команда для работы с фикстурами.

Фикстуры, это файлы отображения базы данных в формат JSON.

Команда `dumpdata` вытащит все данные из базы данных, и преобразует всё в формат JSON.

Может принимать имя только нескольких приложений, или даже только некоторых моделей, или наоборот исключить какие-то
приложения или модели

### loaddata

Команда, обратная команде `dumpdata`. Для загрузки JSON файла в базу данных.

Подробно будем рассматривать эти командны на практике занятия по тестированию django.

### flush

Команда необходимая для очистки базы данных, но не отмены миграций (Сохраняем структуру, теряем все данные)

### sqlflush

Отпечатает какой SQL код будет выполнен при применении команды `flush`

### inspectdb

Команда необходимая для проверки соответствия ваших моделей и вашей базы данных. Незаменимо при переносе проекта из вне
на Django.

### makemigrations

Уже известная вам команда, которая создаёт файлы миграций, и может принимать имя приложения, что бы создать только для
конкретного приложения.

Может принимать важный параметр `--empty`, при этом флаге создастся пустая миграция, никак не привязанная к моделям.
Выглядеть будет примерно вот так:

```python
# Generated by Django 3.0.7 on 2020-10-29 11:59

from django.db import migrations


class Migration(migrations.Migration):
    dependencies = [
        ('storages', '0003_auto_20201029_1352'),
    ]

    operations = [
    ]
```

Тут указано приложение для которого миграция будет применена, и прошлая миграция с которой текущая миграция будет
связана.

Зачем это вообще надо?

Мы можем в операции добавить любые интересующие нас действия, например выполнения кода на python

Для этого нужно добавить класс `RunPython` из пакета `migrations`, который будет принимать два метода, первый будет
выполнен в случае выполнения миграции, второй в случае отката миграции.

```python
# Generated by Django 3.0.7 on 2020-10-29 11:59

from django.db import migrations


def some_forward_action(apps, schema_editor):
    Team = apps.get_model('storages', 'Team')
    Team.objects.create(name='B2B')
    Team.objects.create(name='CX')
    Team.objects.create(name='SFA')


def some_backward_action(apps, schema_editor):
    pass


class Migration(migrations.Migration):
    dependencies = [
        ('storages', '0003_auto_20201029_1352'),
    ]

    operations = [
        migrations.RunPython(some_forward_action, some_backward_action)
    ]
```

Такие миграции называются **Data Migrations**

Чаще всего для того что бы занести какие-либо данные в базу данных на этапе миграции, например создать заведомо
известные объекты, как в моём примере, или для установки вычисляемого значения по умолчанию.

Для обратной миграции чаще всего действия не требуются (хоть и далеко не всегда), поэтому чаще всего обратная миграция
записывается в виде лямбды `lambda x, y: None`

![](https://lh3.googleusercontent.com/proxy/a3WuV3A8umBdVGJA7UVrM50cqloRtS9MhMcq9GYmYwwExEAnYkqNVajL5BBHi_3gwnu4-3s8xDHzTQStrjgrMDZg5lQ)

Типовая Data Migrations:

```python
# Generated by Django 3.0.7 on 2020-10-29 11:59

from django.db import migrations


def some_forward_action(apps, schema_editor):
    Team = apps.get_model('storages', 'Team') # Приложение и модель
    Team.objects.create(name='B2B')
    Team.objects.create(name='CX')
    Team.objects.create(name='SFA')


class Migration(migrations.Migration):
    dependencies = [
        ('storages', '0003_auto_20201029_1352'),
    ]

    operations = [
        migrations.RunPython(some_forward_action, lambda x, y: None)
    ]
```

### migrate

Уже известная вам команда для применения миграции

```
django-admin migrate [app_label] [migration_name]
```

Может быть указано приложение к которому применяется, и имя миграции (на самом деле достаточно первых четырех цифр),
указывание имени нужно для отката миграций, допустим у вас уже применена миграция номер 8, а вы поняли, что проблема
была в миграции номер 6, это значит что можно откатить базу до миграции номер 5. Естественно с потерей данных, и провести
новые миграции, для этого нужно сделать:

```
manage.py migrate my_app 0005
```

Важным флагом является ```--fake```, при применении этого флага, изменения в базу внесены не будут, но Django будет
видеть, что миграция была применена, нужно, что бы использовать базы с уже заполненными данными, созданными вне django
проекта.

Вместо цифр можно указать значение *zero*, что позволяет откатить всю миграции для этого приложения.

### sqlmigrate

Отпечатает какой SQL код будет выполнен при применении команды `migrate`

### showmigrations

Также уже известная вам команда, которая отобразит список миграций, и их состояние (Применена или нет)

### runserver

Команда для запуска тестового сервера, можно указывать порт и многие другие настройки **Не применяется на продакшене,
только для разработки**. Как это делается на продакшене рассмотрим в следующих лекциях.

### sendtestemail

Отправка тестового имейла (работает только если отправка писем была настроена) принимает два параметра, от кого и кому.

Например:

```python manage.py sendtestemail myownemail@gmail.com myanotheremail@gmail.com```

### sqlsequencereset

Команда для сброса последовательностей базы данных, может принимать название приложения.

Если вы удалите все объекты из базы, и начнёте создавать новые, id будут продолжаться в не зависимости от того сколько
объектов было раньше, потому что `id` вычисляется из специальных объектов базы которые называются `sequence`.

Если из сбросить, то id будет назначаться снова с `1`.

**Не применять на базах с данными!!**

### squashmigrations

Команда, которая применяется для того, что бы `сжать` несколько миграций в одну.

Например, в приложении `myapp` миграции от 4-ой до 7-ой это добавления новых полей в одну и туже модель, что бы сжать эти
миграции в одну нужно выполнить

```python manage.py squashmigrations myapp 0004 0007```

### startapp

Команда для создания нового приложения.

### startproject

Команда для создания нового проекта.

### test

Команда для запуска тестов. Рассмотрим её на следующих занятиях.

## Команды базовых приложений

### django.contrib.auth

### changepassword

Команда для смены пароля конкретному пользователю

```manage.py changepassword ringo```

### createsuperuser

Команда для создания пользователя со всеми правами

### django.contrib.sessions

### clearsession

Команда для очистки базы данных от информации о сессиях. При базовых настройках вся информация о сессиях автоматически
пишется в базу данных.

### django.contrib.staticfiles

Команды для статики, вообще работу статики и медиа, рассмотрим на следующих занятиях

## Написание своих скриптов

![](https://lh3.googleusercontent.com/proxy/Tj0Ro_XqtHiWbvJP08D-uhTnI6sGCjJ6qtnzcN5iHgUFdgC21si6dj7mPyso3B0IsiDwkaafjR4IkFVSGahEnbwbxyw)

По факту все выше описанные команды написаны на python, а это значит, что мы можем написать свои команды.

Допустим у нас есть проект пиццерии в рамках которого есть приложение `orders` отвечающее за заказы, и мы хотим, что
бы все заказы которые не были закрыты вручную, ровно в 18:00 были переведены в статус, для ручной проверки, а владелец
заведения получил письмо о том, что такие заказы есть.

Самый простой путь создать manage команду. В приложении создадим папку `management`, а в ней папку `commands`, названия
созданных в этой папке файлов будет соответствовать кастомной manage команде.

```
orders/
    __init__.py
    models.py
    management/
        commands/
            close_orders.py
    tests.py
    views.py
```

В файле нужно создать класс наследованный от `BaseCommand`:

```python
from django.core.management.base import BaseCommand
from orders.models import Order
import send_email


class Command(BaseCommand):
    help = "Close orders which weren't closed manually"

    def handle(self, *args, **options):
        orders = Order.objects.filter(status="opened")
        if orders:
            orders.update(status="manual")
            send_email("Not closed orders", f"Hey, you have {orders.count()} orders with status 'opened'")
            self.stdout.write(self.style.SUCCESS('Successfully closed orders'))
```

Запустить такую команду можно из консоли:

```python manage.py close_orders```

Теперь можно при помощи любой утилиты для работы с консолью поставить задачу в расписание, например для UNIX систем,
можно использовать CRON

```
0 18 * * 1-5 /some/path/pizza/manage.py close_orders
```

## Задания

1. Снять фикстуру с вашей базы, изучить полученный файл.
2. Для вашего модуля создать дата миграцию, которая будет создавать два новых товаров.
3. Написать manage команду, что бы отклонить все заявки на возврат.