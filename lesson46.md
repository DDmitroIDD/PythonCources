# Урок 46. Linux. SSH, Symlinks, Curl, CRON, Nginx/Apache, Demons.

## SSH
![](https://memegenerator.net/img/instances/63165505.jpg)
ЧТО ТАКОЕ SSH?

SSH (от англ. “Secure Shell”) — это протокол удаленного администрирования, разработанный для осуществления удаленного
управления операционными системами и туннелирования TCP-соединения. Использование этого протокола допускает
использование разных алгоритмов шифрования, что позволяет безопасно работать практически в любой незащищенной среде:
работать с ПК через командную оболочку, передавать по шифрованному каналу любой тип данных (например, видео- и
аудиофайлы). Первый релиз протокола состоялся в 1995 г, а уже в 1996 г была представлена усовершенствованная его версия,
которая и стала основой для дальнейшего развития продукта. Сегодня для всех сетевых ОС доступны SSH сервер и SSH клиент,
а сам протокол SSH является одним из самых популярных решений для удаленного управления системами и передачи важной
информации.

На практике по SSH мы обычно будем подключаться к удалённым серверам и иногда передавать через этот протокол файлы (хотя
чаще файлы всё-таки передаются через гит, если мы говорим о развёртывании серверов)

### Принцип работы

SSH это протокол, использующий клиент-серверную модель для аутентификации удаленных систем и обеспечения шифрования
данных, обмен которыми происходит в рамках удаленного доступа.

По умолчанию для работы протокола используется TCP-22 порт: на нем сервер (хост) ожидает входящее подключение и, после
получения команды и проведения аутентификации, организует запуск клиента, открывая выбранную пользователем оболочку. При
необходимости пользователь может менять используемый порт (на практике это очень часто делается). Для создания SSH
подключения клиент должен инициировать соединение с сервером, обеспечив защищенное соединение и подтвердив свой
идентификатор (проверяются соответствие идентификатора с предыдущими записями, хранящимися в RSA-файле, и личные данные
пользователя, необходимые для аутентификации).

### Преимущества протокола

Использование SSH подключения имеет ряд преимуществ:

- безопасная работа на удаленном ПК с использованием командной оболочки; использование разных алгоритмов шифрования (
- симметричного, асимметричного и хеширования); возможность безопасного использования любого сетевого протокола, что
- позволяет передавать по защищенному каналу файлы любого размера.

### Как использовать SSH?

Чтобы обеспечить SSH доступ пользователю необходимы SSH-клиент и SSH-сервер. Каждая операционная система имеет свой
набор программ, обеспечивающих соединение. Так, для Linux это lsh (server и client), openssh (server и client). Для Mac
OS зачастую используется NiftyTelnet SSH. А в ОС Windows для реализации соединения через SSH протокол чаще всего
используется приложение [PuTTY](https://www.putty.org).

### Базовый синтаксис

![](https://www.meme-arsenal.com/memes/f81720f80fc3569a8830ef592672816f.jpg)

Синтаксис команды для подключения из linux к другому линукс выглядит следующим образом:

`ssh [опции] имя пользователя@сервер [команда]`

Я для такого подключения буду использовать терминал GIT для Windows который я при установке настроил как консоль linux.
На самом деле Windows 10/11 содержат в себе урезанное ядро линукса, что и позволяет использовать некоторые базовые
команды и синтаксис линукса.

На самом деле все конфигурации ssh сервера находятся в папке /etc/ssh/, если хотите деталей, можете изучить их
самостоятельно.

Из интересного там есть возможность изменить стандартный порт с 22, ограничить пользователей или группы которые могут
подключаться итд.

Для подключения нужно использовать команду

`ssh user@host`

Где `user` - это имя пользователя от чьего имени мы хотим подключиться.

А `host` - это IP или URL адрес машины к которой мы хотим подключиться. На практике этот параметр чаще всего будет
предоставлен компанией у которой мы будем арендовать сервер (а чаще всего используется именно арендованные сервера),
либо если вам необходим собственный сервер, он должен быть обеспечен статическим IP адресом для выхода в интернет.

После такого запроса команда затребует пароль от пользователя. И как чаще всего бывает при введении пароля в linux,
никакие введённые символы отображаться не будут, но всё работает.

### SSH ключи

![](https://www.memecreator.org/static/images/memes/5052825.jpg)

Использовать вход по паролю можно, но чаще всего не нужно :)

При использовании входа по паролю, появляется одна проблема, такой пароль может перебрать злоумышленник, и на практике
это вполне возможно. А мы же не хотим подарить кому-то, и код, и пароли от базы данных итд.

Поэтому чаще всего используются ssh ключи. Это специально сгенерированные 2 (чаще всего два) файла, причём
сгенерированные так, что имея один из ключей, можно при помощи специальных алгоритмов проверить, подходит ли он ко
второму. Один из них называется public (публичный или открытый), второй это private (приватный или закрытый). Публичный
ключ мы можем оставлять почти где угодно без особых переживаний, а вот приватный всегда должен оставаться в тайне (как и
пароль, так как используется для этих же целей)

#### Как сгенерировать такие ключи?

![](https://cs12.pikabu.ru/post_img/big/2021/07/06/0/1625518968161312915.png)

Для этого в линуксе существует специальная команда

`ssh-keygen -t rsa`

Параметр -t отвечает за то какой именно алгоритм шифрования нужно использовать для нас обычно подходит два
алгоритма `rsa` или `dsa`, я чаще пользуюсь `rsa`.

После введения команды, командная строка спросит нас о некоторых деталях. Куда именно сложить полученные файлы (по
умолчанию будет использована папка `~/.ssh/`, рекомендую не менять), и так называемую кодовую фразу, она не является
обязательной, можно оставить пустую строку, по сути эта фраза будет являться уже паролем от нашего закрытого ключа, на
практике обычно нет особого смысла задавать эту фразу.

После генерации, в указанной папке сгенерируются два файла, `some_key_name` и `some_key_name.pub`, без расширения это
закрытый ключ, с расширением `.pub` это публичный ключ.

Обычно эти ключи генерируются сразу на удалённом сервере куда мы в последствии собираемся подключаться. Для того, что бы
мы могли подключиться закрытый ключ нужно переместить в правильную папку с правильным названием файла `authorized_keys`.

`cat some_key_name.pub >> ~/.ssh/authorized_keys`

Файл оригинала обычно удаляется, и больше приватный ключ не трогается

`rm some_key_name.pub`

Теперь достаточно скопировать файл публичного ключа (любым доступным способом, хоть в ручную переписать, обычно там
будет храниться 3-5 строк символов), туда откуда мы собираемся подключаться.

Для подключения по ssh через ключи необходимо указать параметр `-i` в котором указать путь к открытому ключу, допустим
мы скопировали такой файл в папку `~/.ssh/`, как чаще всего и делается, то подключиться можно так.

`ssh user@host -i ~/.ssh/some_key_name.pub`

#### Арендованные сервера

![](https://i.imgflip.com/1kqp4d.jpg)

Обычно когда мы арендуем машину у какой-либо компании, нам сразу при покупке предоставят, юзернейм, хост, и файл
открытого ключа. Что позволяет нам сразу подключиться к такой машине не заморачиваясь с настройкой подключения.

## Symlinks

![](https://memegenerator.net/img/instances/27642388.jpg)

Симлинк это сокращение от "символическая ссылка".

Символическая («мягкая») ссылка (также «симлинк», от англ. Symbolic link) — специальный файл в файловой системе, в
котором вместо пользовательских данных содержится путь к файлу, открываемому при обращении к данной ссылке (файлу).

Целью ссылки может быть любой объект: например другая ссылка, файл, каталог или даже несуществующий файл (в последнем
случае при попытке открыть его должно выдаваться сообщение об отсутствии файла). Ссылка, указывающая на несуществующий
файл, называется висячей или битой.

Символические ссылки используются для более удобной организации структуры файлов на компьютере, так как:

- позволяют для одного файла или каталога иметь несколько имён и различных атрибутов; свободны от некоторых ограничений,
- присущих жёстким ссылкам (последние действуют только в пределах одной файловой системы (одного раздела) и не могут
  ссылаться на каталоги).

Такие типы файлов существуют в различных операционных системах включая Windows.

Для создания такой ссылки в linux используется команда `ln`

`ln -s файл имя_ссылки`

Такие ссылки мы будем использовать для передачи северам файлов конфигурации.

## Что Такое Curl и Как работает Эта Команда?

![](https://www.meme-arsenal.com/memes/3dd9faecb86c76b3f09e80a081f6288c.jpg)

Что такое Curl? Curl — это сокращение от “Client URL”. Утилита доступна в большинстве систем на основе Unix и
предназначена для проверки подключения к URL-адресам. Кроме того команда Curl — отличный инструмент передачи данных.
Давайте же узнаем, как ею пользоваться.

По факту curl это тот же самый Postman прямо из командной строки

Команда Curl поддерживает следующий список протоколов:

- HTTP и HTTPS
- FTP и FTPS
- IMAP и IMAPS
- POP3 и POP3S
- SMB и SMBS
- SFTP
- SCP
- TELNET
- GOPHER
- LDAP и LDAPS
- SMTP и SMTPS

Это наиболее важные поддерживаемые протоколы, но есть и другие. Curl работает на libcurl, которая является бесплатной
библиотекой для передачи URL на стороне клиента.

### Проверка Версии Curl

Сначала давайте проверим её доступною версию, с помощью следующей команды:

`curl --version`

В выводе вы должны увидеть версию и список поддерживаемых протоколов. Теперь мы можем взглянуть на некоторые примеры
команд Curl.

### Основной Синтаксис Команды Curl

![](https://memegenerator.net/img/instances/72569805.jpg)

Итак, давайте узнаем, как пользоваться утилитой. Основной синтаксис Curl выглядит следующим образом:

`curl [OPTIONS] [URL]`

Самый простой пример использования Curl — для отображения содержимого страницы. Приведённая ниже команда отобразит
домашнюю страницу testdomain.com.

`curl testdomain.com`

Эта команда отобразит полный исходный код домашней страницы домена. Если протокол не указан, Curl интерпретирует его как
HTTP.

### Команда Curl для Работы с Файлами

Команды Curl могут загружать файлы из удалённой локации. Есть два способа это сделать:

- \-O сохранит файл в текущем рабочем каталоге с тем же именем, что и у удалённого;
- \-o позволяет указать другое имя файла или местоположение.

- Вот пример:

`curl -O http://testdomain.com/testfile.tar.gz`

Приведённая выше команда сохранит файл как testfile.tar.gz.

`curl -o newtestfile.tar.gz http://testdomain.com/testfile.tar.gz`

А эта команда сохранит его как newtestfile.tar.gz.

Если по какой-либо причине загрузка будет прервана, вы можете возобновить её с помощью следующей команды:

`curl -C - -O  http://testdomain.com/testfile.tar.gz`

Curl также позволяет загрузить несколько файлов одновременно. Пример:

`curl -O http://testdomain.com/testfile.tar.gz -O http://mydomain.com/myfile.tar.gz`

Если вы хотите загрузить несколько файлов с нескольких URL, перечислите их все в файле. Команды Curl могут быть
объединены с xargs для загрузки различных URL-адресов.

Например, если у нас есть файл allUrls.txt, который содержит список всех URL-адресов для загрузки, то приведённый ниже
пример выполнит загрузку всех файлов с этих URL.

`xargs –n 1 curl -O < allUrls.txt`

### Команды Curl для HTTP

Типичный HTTP-запрос всегда содержит заголовок. Заголовок HTTP отправляет дополнительную информацию об удалённом
веб-сервере вместе с фактическим запросом. С помощью инструментов разработчика в браузере вы можете посмотреть сведения
о заголовке, а проверить их можно с помощью команды curl.

Пример ниже демонстрирует, как получить информацию о заголовке с веб-сайта.

`curl -I www.testdomain.com`

Используя curl, вы можете сделать запрос GET и POST. Запрос GET будет выглядеть следующим образом:

`curl http://mydomain.com`

А вот пример запроса POST:

`curl –data “text=Hello” https://myDomain.com/firstPage.jsp`

Здесь text=Hello — это параметр запроса POST. Такое поведение похоже на HTML-формы.

Вы также можете указать несколько методов HTTP в одной команде curl. Сделайте это, используя опцию –next, например:

`curl –data “text=Hello” https://myDomain.com/firstPage.jsp --next https://myDomain.com/displayResult.jsp`

Команда содержит запрос POST, за которым следует запрос GET.

Каждый HTTP-запрос содержит агент пользователя, который отправляется как часть запроса. Он указывает информацию о
браузере клиента. По умолчанию запрос содержит curl и номер версии в качестве информации об агенте пользователя. Пример
вывода показан ниже:

`“GET / HTTP/1.1” 200 “_” ”curl/7/29/0”`

Вы можете изменить дефолтную информацию об агенте пользователя, используя следующую команду:

`curl -I http://mydomain.com –-user-agent “My new Browser” `

Теперь вывод будет выглядеть так:

`“GET / HTTP/1.1” 200 “_” ”My new Browser”`

При помощи параметра `-U` можно указать параметры авторизации:

`curl -U username:password -O http://testdomain.com/testfile.tar.gz`

### Команда Curl и Cookies

Утилиту можно использовать для проверки того, какие файлы cookie загружаются по URL. Допустим вы зашли
на https://www.samplewebsite.com, вы можете вывести и сохранить файлы cookie в файл, а затем получить к ним доступ,
используя команду cat или редактор Vim.

Вот пример такой команды:

`curl --cookie-jar Mycookies.txt https://www.samplewebsite.com /index.html -O`

Точно так же, если у вас есть файлы cookie в файле, вы можете отправить их на сайт. Вот, как это будет выглядеть:

`curl --cookie Mycookies.txt https://www. samplewebsite.com`

## Что такое Cron и crontab?

![](https://memegenerator.net/img/instances/11091908.jpg)

Если в двух словах, то Cron – это планировщик задач. Если подробнее, то это утилита, позволяющая выполнять скрипты на
сервере в назначенное время с заранее определенной периодичностью.

К примеру, у вас есть скрипт, который собирает какие-либо статистические данные каждый день в 6 часов вечера. Такие
скрипты называют «заданиями», а их логика описывается в специальных файлах под названием сrontab.

crontab – это таблица с расписанием запуска скриптов и программ, оформленная в специальном формате, который умеет
считывать компьютер. Для каждого пользователя системы создается отдельный crontab-файл со своим расписанием. Эта
встроенная в Linux утилита доступна на низком уровне в каждом дистрибутиве.

В Linux-дистрибутивах с поддержкой systemd (о нём дальше) Cron считается устаревшим решением, его заменили утилитой
systemd.timer. Ее предназначение и функциональность не отличается, но фактически частота использования Cron все еще
выше.

### Для чего обычно используют Cron?

Обычно Cron заставляют повторять вполне очевидные задачи в духе регулярного создания резервных копий данных. Но это не
все.

- Некоторые пользователи с помощью планировщика корректируют системное время. На многих компьютерах оно настраивается
  через Network Time Protocol. А так как этот протокол настраивает только время ОС, время, установленное для «железа»,
  может отличаться. Cron позволяют регулярно корректировать время, установленное для аппаратного обеспечения, в
  соответствии со временем ОС.

- Еще один популярный сценарий – создание оповещений, появляющихся каждое утро и рассказывающих о состоянии компьютера.
  В эти сообщения может входить любая полезная для пользователя информация.

- Cron иногда работает даже без ведома пользователя. Эту утилиту используют такие сервисы, как Logwatch, logrotate и
  Rootkit Hunter. Повторяющиеся задачи они настраивают, как и пользователи, через Cron. С помощью Cron пользователи
  автоматизируют самые разные задачи, сокращая вмешательство системного администратора в работу сервера.

### Базовые принципы работы с Cron и crontab

![](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSpjZrm5QkTv_6bwEJvbjcoUxAdccvMTFDXqw&usqp=CAU)

Планировать задачи через панель управления удобно, но не всегда возможно. Не все хостинг-провайдеры предлагают такие
функциональные веб-интерфейсы. В этом случае придется воспользоваться командной строкой, подключившись к серверу по
протоколу Secure Shell.

Для работы с планировщиком в системе есть ряд команд, помогающих решать основные задачи:

- crontab -e – открывает конфигурационный файл (поговорим о нем чуть подробнее в разделе с первичной настройкой).
- crontab -l – показывает список задач из конфигурационного файла (все, что было запланировано).
- crontab -r – удаляет конфигурационный файл вместе со всеми запланированными задачами.
- сrontab -v – показывает, когда в последний раз открывался конфигурационный файл.

Чтобы запланировать задачи, используя командную строку, необходимо выполнить базовую настройку Cron, проверить, не
установлены ли ограничения, и заполнить расписание задач в соответствии с синтаксисом сrontab.

#### Первичная настройка Cron

Как мы уже выяснили ранее, планировщик черпает параметры для выполнения своих задач из crontab-файлов (таблиц с
расписанием). У каждого пользователя, включая root, должен быть свой crontab-файл. По умолчанию он не существуют,
поэтому придется создать его вручную.

Для этого существует команда `crontab -e`. Она автоматически генерирует таблицу в директории /var/spool/cron.

Вновь созданный файл будет пустым текстовым полем. Необходимо добавлять в него все параметры самостоятельно с нуля,
опираясь на синтаксис сrontab (более подробно поговорим о нем ниже). После ввода параметров нужно сохранить параметры
редактора, нажав на клавишу F2, а затем покинуть конфигурационный файл, нажав на клавишу F10. При введении корректных
параметров в терминале отобразится строка crontab: installing new crontab.

Опытные разработчики и системные администраторы не рекомендуют использовать для редактирования расписания текстовые
редакторы в духе Nano, Emacs или Vi. Команды crontab позволяют не только внести изменения в таблицу запланированных
задач, но и перезапустить фоновый процесс crond, отвечающий за работу утилиты после сохранения настроек.

#### Ограничения Cron

![](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTDkfYIhJeq6u4ZQ3ViG6Xdd86CSbOpvcXMKg&usqp=CAU)

У Cron есть функция установки ограничений на использование, задающихся через два специальных файла: cron.allow и
cron.deny.

Первый файл находится в директории /usr/lib/cron/cron.allow и содержит в себе список учетных записей (имен
пользователей), которые имеют право на планирование задач с помощью встроенных системных утилит.

Второй файл находится в директории /usr/lib/cron/cron.deny. В нем указываются имена пользователей, которые не могут
запускать встроенный в систему планировщик задач.

Если первого файла не существует, то любой пользователь может планировать задачи с помощью встроенного в систему
планировщика, но только при условии, что его имени нет во втором файле. Если удалить оба файла, то каждый пользователь
сможет планировать задачи без ограничений.

### Синтаксис crontab

![](https://1.bp.blogspot.com/-dbteCGwlhiE/XtwtXvwrVRI/AAAAAAAAm2w/gHmQ3kbo-sY94tXSlvCO3wcikb6o4jY1wCK4BGAsYHg/w1200-h630-p-k-no-nu/cron-jobs-cron-jobs-everywhere.jpg)

```
# crontab -e
SHELL=/bin/bash
MAILTO=mymail@someprovider.com
PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin

# Детали смотрите в следующих разделах

# Примеры оформления задач в планировщике (формат данных):
# .---------------- минуты (0 - 59)
# |  .------------- часы (0 - 23)
# |  |  .---------- дни месяца (1 - 31)
# |  |  |  .------- сами месяцы (1 - 12) OR jan,feb,mar,apr ...
# |  |  |  |  .---- дни недели (0 - 6) (0 или 7 это воскресенье в зависимости от настроек системы) можно использовать сокращения типа mon,tue,wed,thu,fri,sat,sun
# |  |  |  |  |
# *  *  *  *  * имя пользоваться  команда, которую нужно запустить

# создание копии всей операционной системы с помощью кастомного скрипта 
01 01 * * * /usr/local/bin/bckp -vbd1 ; /usr/local/bin/bckp -vbd2

# установка соответствия между временем операционной системы и "железа"
03 05 * * * /sbin/hwclock --systohc

# проведение обновления операционной системы в заданный период времени
25 04 1 * * /usr/bin/apt-get update
```

Первые три линии кода в таблице отвечают за первичную настройку. Сначала указывается оболочка, в которой будет работать
Cron. У утилиты нет каких-либо предпочтений, поэтому можно указать любую на собственное усмотрение (в нашем примере это
bash). Затем указывается адрес электронный почты, на который будут отправляться отчеты о работе планировщика. И
напоследок указывается путь к окружению.

Ниже находятся параметры, используемые для запуска процессов в определенный период времени. В комментариях описан
базовый синтаксис, включающий в себя формат времени, имя пользователя и команду, которая должна быть запущена.

В нашем случае указаны команды:

```
02 04 5 * * /usr/local/bin/bckp -vbd1 ; /usr/local/bin/bckp -vbd2
04 06 * * * /sbin/hwclock –systohc
10 05 5 * * /usr/bin/apt-get update
05 * * * * rm /home/myusername/tmp/*
```

### Примеры использования Cron в командной строке

Команда

`02 04 5 * * /usr/local/bin/bckp -vbd1 ; /usr/local/bin/bckp -vbd2`

создает в таблице расписания задачу на запуск скрипта под названием bckp (представим, что такой существует), который
создает резервную копию всей системы на стороннем накопителе. Он выполняется 5 числа каждого месяца в 4 часа 2 минуты
утра. Это видно по числовым значениям. Звездочки же указывают на отсутствие конкретного значения. Cron воспринимает их
как «выполнять каждый раз», то есть каждый месяц, день или неделю.

Команда

`04 06 * * * /sbin/hwclock –systohc`

меняет время аппаратного обеспечения на то, что используется в системе. Делает это каждый день, каждую неделю и каждый
месяц в 6 часов 4 минуты утра. Как видите, здесь пропущено третье значение. Поэтому команда и запускается ежедневно, так
как нет более конкретных правил.

Команда

`10 05 5 * * /usr/bin/apt-get update`

запускает обновление пакетов с помощью пакетного менеджера apt каждый месяц 5 числа в 05:10.

Команда

`05 * * * * rm /home/myusername/tmp/*`

удаляет содержимое папки с временными файлами для конкретного пользователя (меня) на пятой минуте (первый пункт) каждого
часа. Так как определенные значения отсутствуют для всех остальных пунктов, получается, что скрипт готов выполняться
каждый день, каждый месяц и каждый час. Но первое значение указано, поэтому он будет дожидаться пятой минуты и
запускаться в этот момент. То есть в 12:05, 13:05, 14:05 и т.п.

Как видите, разобраться с базовыми командами несложно.

## Nginx/Apache

![](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRbdwnrtgF2wMDLg7O0FhfYy1r4ZRFmeaU1XA&usqp=CAU)

Apache и Nginx — 2 самых широко распространенных веб-сервера с открытым исходным кодом в мире. Вместе они обслуживают
более 60% трафика во всем интернете. Оба решения способны работать с разнообразными рабочими нагрузками и
взаимодействовать с другими приложениями для реализации полного веб-стека.

Несмотря на то, что у Apache и Nginx много схожих качеств, их нельзя рассматривать как полностью взаимозаменяемые
решения. Каждый из них имеет собственные преимущества и важно понимать какой веб-сервер выбрать в какой ситуации. В этой
статье описано то, как каждый из этих веб-серверов ведет себя при различных условиях.

### Общий обзор

Прежде чем погрузиться в различия между Apache и Nginx давайте бегло взглянем на предысторию каждого из этих проектов.

#### КРАТКИЙ ОБЗОР Apache

![]()
Apache был разработан для доставки веб-контента, доступ к которому осуществляется через Интернет. Он известен тем, что
играл ключевую роль в начальном росте интернета. Apache - это программное обеспечение с открытым исходным кодом,
разработанное и поддерживаемое открытым сообществом разработчиков и работающее в самых разных операционных системах.
Архитектура включает в себя ядро Apache и модули. Основной компонент предоставляет базовую серверную функцию, поэтому он
принимает соединения и управляет параллелизмом. Различные модули соответствуют различным функциям, которые выполняются
по каждому запросу. Конкретное развертывание Apache может быть сконфигурировано для включения различных модулей, таких
как функции безопасности, управление динамическим контентом или для базовой обработки HTTP-запросов.

Модель «один сервер делает все» стала ключом к раннему успеху Apache. Однако по мере увеличения уровня трафика и
увеличения количества веб-страниц и ограничения производительности настройка Apache на работу с реальным трафиком
усложнялась.

#### КРАТКИЙ ОБЗОР Nginx

![](https://memegenerator.net/img/instances/67297269.jpg)

Nginx был разработан специально для устранения ограничений производительности веб-серверов Apache. Производительность и
масштабируемость Nginx обусловлены архитектурой, управляемой событиями. Он значительно отличается от подхода Apache. В
Nginx каждый рабочий процесс может одновременно обрабатывать тысячи HTTP-соединений. Следовательно, Nginx - это
легковесная, масштабируемая и высокопроизводительная реализация. Эта архитектура делает обработку больших и
флуктуирующих нагрузок на данные гораздо более предсказуемой с точки зрения использования ОЗУ, использования ЦП и
задержки.

Nginx также имеет богатый набор функций и может выполнять различные роли сервера:

- Обратный прокси-сервер для протоколов HTTP, HTTPS, SMTP, POP3 и IMAP
- Балансировщик нагрузки и HTTP-кеш
- Интерфейсный прокси для Apache и других веб-серверов, сочетающий гибкость Apache с хорошей производительностью
  статического контента Nginx

### APACHE ПРОТИВ NGINX: СРАВНЕНИЕ ИХ БОГАТЫХ НАБОРОВ ФУНКЦИЙ

#### ПРОСТОТА

Разрабатывать и обновлять приложения на Apache очень просто. Модель «одно соединение на процесс» позволяет очень легко
вставлять модули в любой точке логики веб-обслуживания. Разработчики могут добавлять код таким образом, что в случае
сбоев будет затронут только рабочий процесс, выполняющий код. Обработка всех других соединений будет продолжаться без
помех.

Nginx, с другой стороны, имеет сложную архитектуру, поэтому разработка модулей не легка. Разработчики модулей Nginx
должны быть очень осторожны, чтобы создавать эффективный и точный код, без сбоев, и соответствующим образом
взаимодействовать со сложным ядром, управляемым событиями, чтобы избежать блокирования операций.

#### ПРОИЗВОДИТЕЛЬНОСТЬ

Производительность измеряется тем, как сервер доставляет большие объемы контента в браузер клиента, и это важный фактор.
Контент может быть статическим или динамическим. Давайте посмотрим статистику по этому вопросу.

#### СТАТИЧЕСКИЙ КОНТЕНТ

Nginx работает в 2,5 раза быстрее, чем Apache, согласно тесту производительности, выполняемому до 1000 одновременных
подключений. Другой тест с 512 одновременными подключениями показал, что Nginx примерно в два раза быстрее и потребляет
меньше памяти. Несомненно, Nginx имеет преимущество перед Apache со статическим контентом. Поэтому, если вам нужно
обслуживать одновременный статический контент, Nginx является предпочтительным выбором.

#### ДИНАМИЧЕСКИЙ КОНТЕНТ

Результаты тестов Speedemy показали, что для динамического контента производительность серверов Apache и Nginx была
одинаковой. Вероятная причина этого заключается в том, что почти все время обработки запросов расходуется в среде
выполнения PHP, а не в основной части веб-сервера. Среда выполнения PHP довольно похожа для обоих веб-серверов.

Apache также может обрабатывать динамический контент, встраивая процессор языка, подобного PHP, в каждый из его рабочих
экземпляров. Это позволяет ему выполнять динамический контент на самом веб-сервере, не полагаясь на внешние компоненты.
Эти динамические процессоры могут быть включены с помощью динамически загружаемых модулей.

Nginx не имеет возможности обрабатывать динамический контент изначально. Чтобы обрабатывать PHP и другие запросы на
динамический контент, Nginx должен перейти на внешний процессор для выполнения и дождаться отправки визуализированного
контента. Однако этот метод также имеет некоторые преимущества. Поскольку динамический интерпретатор не встроен в
рабочий процесс, его издержки будут присутствовать только для динамического содержимого.

#### ПОДДЕРЖКА ОС

Apache работает во всех операционных системах, таких как UNIX, Linux или BSD, и полностью поддерживает Microsoft
Windows. Nginx также работает на нескольких современных Unix-подобных системах и поддерживает Windows, но его
производительность в Windows не так стабильна, как на платформах UNIX.

#### БЕЗОПАСНОСТЬ

![](http://risovach.ru/upload/2013/07/mem/tipichnyj-zloj-rolevik_24789113_orig_.jpg)

И Apache, и Nginx являются безопасными веб-серверами. Apache Security Team существует, чтобы предоставить помощь и
советы проектам Apache по вопросам безопасности и координировать обработку уязвимостей безопасности. Важно правильно
настроить серверы и знать, что делает каждый параметр в настройках.

#### ГИБКОСТЬ

Веб-серверы могут быть настроены путем добавления модулей. Apache долго загружал динамические модули, поэтому все модули
Apache поддерживают это.

Nginx Plus (Nginx Plus - это программный балансировщик нагрузки, веб-сервер и кэш контента, построенный на основе
открытого исходного кода Nginx) также использует модульную архитектуру. Новые функции и возможности могут быть добавлены
с программными модулями, которые могут быть подключены к работающему экземпляру Nginx Plus по требованию. Динамические
модули добавляют в Nginx Plus такие функции, как геолокация пользователей по IP-адресу, изменение размеров изображений и
встраивание сценариев Lua в модель обработки событий Nginx Plus. Модули создаются как Nginx, Inc., так и сторонними
разработчиками.

Большинство необходимых функциональных возможностей основного модуля (например, прокси, кэширование, распределение
нагрузки) поддерживаются обоими веб-серверами.

#### ПОДДЕРЖКА И ДОКУМЕНТАЦИЯ

Важным моментом, который следует учитывать, является доступная справка и поддержка веб-серверов среди прочего
программного обеспечения. Поскольку Apache был популярен так долго, поддержка сервера довольно распространена
повсеместно. Для главного сервера и для основанных на задачах сценариев, связанных с подключением Apache к другому
программному обеспечению, имеется большая библиотека документации первого и стороннего производителя.

Наряду с документацией многие инструменты и веб-проекты содержат инструменты для начальной загрузки в среде Apache. Это
может быть включено в сами проекты или в пакеты, поддерживаемые отделом упаковки вашего дистрибутива.

Apache, как правило, получает большую поддержку от сторонних проектов просто из-за своей доли рынка и продолжительности
времени, в течение которого он был доступен.

В прошлом для Nginx было трудно найти исчерпывающую англоязычную документацию из-за того, что большая часть ранней
разработки и документации была на русском языке. Однако на сегодняшний день документация заполнена, и на сайте Nginx
имеется множество ресурсов для администрирования и доступной документации от третьих лиц.

#### NGINX И APACHE - СОВМЕСТНАЯ РАБОТА
![](https://memegenerator.net/img/instances/50088378.jpg)
Для многих приложений Nginx и Apache хорошо дополняют друг друга. Очень распространенным начальным шаблоном является
развертывание программного обеспечения Nginx с открытым исходным кодом в качестве прокси-сервера (или Nginx Plus в
качестве платформы доставки приложений) перед веб-приложением на основе Apache. Nginx выполняет тяжелую работу,
связанную с HTTP - обслуживает статические файлы, кэширует содержимое и разряжает медленные HTTP-соединения - так что
сервер Apache может выполнять код приложения в безопасной и защищенной среде.

### Дополнение

В случае с разворачиванием проектов на python, мы будем использовать nginx как прокси сервер, а вот в случае с
обработкой данных, мы будем использовать совсем другие технологии, о них на следующем занятии.

## Демонизация

Тут будет еще текст :)
