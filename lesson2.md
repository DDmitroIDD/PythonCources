# Лекция 2. Булева алгебра и условия

![](https://upload.wikimedia.org/wikipedia/commons/thumb/c/ce/George_Boole_color.jpg/274px-George_Boole_color.jpg)

## Что такое булева алгебра?

Булева алгебра – это раздел математики, который занимается операциями над логическими значениями и включает двоичные
переменные. Булева алгебра ведет свое начало от книги математика Джорджа Буля (на картинке выше) 1854 года.

Основные понятия в булевой алгебре это **true** и **false**, они же **истина** и **ложь**, и три оператора **not**, *
*and**, и **or**. Они же **не**, **и** и **или**.

Очень большая часть программирования строится именно на двоичной алгебре и оперирует понятиями из этой алгебры.

Тип **Python boolean** является одним из встроенных типов данных Python. Он используется для представления истинности
значения выражения. Например, выражение ``1 < 2`` является ``True``, тогда как выражение ``0 == 1`` является ``False``.
Понимание того, как ведут себя логические значения Python, важно для качественного программирования на Python.

Запомните слова **True** и **False** именно с большой буквы – они являются ключевыми в языке Python, и вы не можете
использовать их как название переменной, функции, класса и т.д.

Эти понятия есть в каждом языке программирования (которые используются коммерчески, возможно, есть исключения для
некоторых проектов, сделанных для веселья), которые мне известны.

![](https://i.imgflip.com/55t2ce.jpg)

Такой тип данных называется **булевый**, а такие переменные – **булевые**.

### Давайте разбираться, что это за тип данных.

Может быть только два значения: *True* и *False*.

![](https://static.vecteezy.com/system/resources/previews/004/581/253/original/check-and-cross-icon-right-and-wrong-icon-yes-or-no-buttons-true-or-false-good-or-bad-selection-design-design-free-vector.jpg)
Есть три способа, как переменная может быть булевым значением:

1) Явное создание переменной такого типа:

```python
some_true_variable = True
some_false_variable = False
```

2) Приведение типов

Как вы уже знаете в python-е есть разные типы данных, например, числа, строки и булевые значения. На самом деле их
намного больше, и мы будем их изучать.

Python это язык с динамической строгой типизацией, а это значит, что мы не обязаны указывать какой тип переменной мы
создаем, но мы не можем сложить или сравнить между собой число и строку.

А что если нам нужно сложить число со строкой? Например, у нас есть переменная со значением 45 и другая со значением "
47".

Первая — это число, вторая — это строка. В таком случае у нас есть два варианта. Первый — сложить переменные как
числа, второй — сложить их как строки. Чтобы у нас была такая возможность, мы должны изменить тип одной из них, а затем
работать с одним и тем же типом данных. Чтобы привести один тип к другому, все, что нам нужно, это написать название
типа маленькими буквами и в скобках указать, что именно мы хотим изменить.

```python
my_num = 45  # Это число
my_str = '47'  # Это строка
print(my_num + my_str)  # Вызовет ошибку 
print(my_num + int(my_str))  # Распечатает 92
print(str(my_num) + my_str)  # Распечатает 4547

my_str_not_number = 'blabla'
int(my_str_not_number)  # Вызовет ошибку!! Эта строка не может быть преобразована в число
```

То же самое и с булевым типом, мы можем преобразовать что угодно в булевый тип **bool(anything)**.

Для каждого типа данных свои правила преобразования к логическому типу. Для чисел и строк они такие:

Любая непустая строка преобразуется в **True**.

```python
bool('')  # False
bool('asdasd')  # True
empty_string = ''
not_empty_string = 'some text'
bool(empty_string)  # False
bool(not_empty_string)  # True
```

С числами правила не сложнее, любое значение, которое не равно **0**, это True.

```python
bool(4)  # True
bool(0)  # False
bool(-3)  # True
positive = 5
negative = -4
zero = 0
bool(positive)  # True
bool(zero)  # False
bool(negative)  # True
bool(positive - 5)  # False
bool(0.0)  # False
```

3) Как результат математического сравнения или результат некоторых ключевых слов.

#### Математические сравнения

Для сравнения в python используются математические символы

Можно сравнивать строки, числа, и многие другие типы данных, что детально мы разберем позже.

**>** - больше,

```python
result = 5 > 3  # True
another_result = 3 > 5  # False
compare_the_same_values = 3 > 3  # False
small_value = 4
big_value = 6
compare_variables = big_value > small_value  # True
compare_variables = small_value > big_value  # False
compare_strings = 'ab' > 'baa'  # False, базовое сравнение строк происходит по алфавиту
```

**<** - меньше, логика такая же

```python
result = 5 < 3  # False
another_result = 3 < 5  # True
compare_the_same_values = 3 < 3  # False
small_value = 4
big_value = 6
compare_variables = big_value < small_value  # False
compare_variables = small_value < big_value  # True
compare_strings = 'ab' < 'baa'  # True
```

**>=** - Больше или равно

```python
result = 5 >= 3  # True
another_result = 3 >= 5  # False
compare_the_same_values = 3 >= 3  # True
small_value = 4
big_value = 6
compare_variables = big_value >= small_value  # True
compare_variables = small_value >= big_value  # False
compare_strings = 'ab' >= 'baa'  # False
```

**<=** - меньше или равно

```python
result = 5 <= 3  # True
another_result = 3 <= 5  # False
compare_the_same_values = 3 <= 3  # True
small_value = 4
big_value = 6
compare_variables = big_value <= small_value  # False
compare_variables = small_value <= big_value  # True
compare_strings = 'ab' <= 'baa'  # True
```

**==** - равно (да там два символа равно, потому что один символ равно уже занят присвоением значения переменной)

```python
result = 5 == 3  # False
another_result = 3 == 5  # False
compare_the_same_values = 3 == 3  # True
small_value = 4
big_value = 6
compare_variables = big_value == small_value  # False
compare_variables = small_value == big_value  # False
compare_strings = 'ab' == 'baa'  # False
```

#### Ключевые слова булевой алгебры

**and** - логическое **и**, !!! РЕЗУЛЬТАТ МОЖЕТ БЫТЬ НЕ БУЛЕВОЕ ЗНАЧЕНИЕ

Логическое **и** работает так. Если все значения в выражении истинны, результат также будет истинен. Но имейте в виду,
что это ключевое слово не возвращает булево значение, оно возвращает первое значение, которое при преобразовании в
булево будет ложным, или последнее, если оба истинны. Давайте лучше посмотрим примеры.

Логическому **и** и логическому **или** можно передавать разные типы данных слева и справа.

```python
True and True  # True
False and True  # False
False and False  # False
True and False  # False
True and ''  # ''
'a' and 0  # 0
0 and ''  # 0
10 and ''  # ''
'bla' and 23  # 23
```

**or** - логическое **или**, !!! РЕЗУЛЬТАТ МОЖЕТ БЫТЬ НЕ БУЛЕВОЕ ЗНАЧЕНИЕ

Логическое **или** работает так. Если одно значение в выражении истинно, результат также будет истинен. Но имейте в
виду,
что это ключевое слово не возвращает булево значение, оно возвращает первое значение, которое при преобразовании в
булево будет истинным, или последнее, если оба ложны. Давайте лучше посмотрим примеры.

```python
True or True  # True
False or True  # True
False or False  # False
True or False  # True
True or ''  # True
'a' or 0  # 'a'
0 or ''  # ''
10 or ''  # 10
'bla' or 23  # 'bla'
```

**not** - преобразует True в False и наоборот. Сначала преобразует значение в булево, а затем меняет на противоположное.

```python
not True  # False
not False  # True
not ''  # True
not 33  # False
```

**in** - поиск подколлекции в коллекции. На этом уровне знаний используется для поиска вхождения одной строки в другую:

```python
'ab' in 'bcde'  # False
'ab' in 'abcd'  # True
```

**is** - **ИСПОЛЬЗУЕТСЯ ТОЛЬКО С ПЕРЕМЕННЫМИ**, это проверка, находятся ли две переменные в одном и том же месте в
памяти. Это немного сложно для понимания, и будет намного проще объяснить это, когда вы будете знать другие типы данных.
Но объясню на некоторых примерах:

```python
a = 500
b = 500
a is b  # False
c = 500
d = c
c is d  # True
```

Но у Python есть одна особенность работы этого оператора. Разработчики языка программирования решили, что числа от -5 до
255 используются очень часто, и нет никакого смысла создавать для этих чисел новую переменную каждый раз. Поэтому они
сделали так, чтобы при запуске скрипта значения от -5 до 255 брались из внутренней памяти. Из-за этого возникает очень
интересный эффект, и я очень люблю спрашивать об этом на собеседованиях.

```python
a = 200
b = 200
a is b  # True
a = 300
b = 300
a is b  # False
```

### Розбираємося з пріоритетом операторів

На самом деле, как и в обычной математике, у любых операторов есть свой приоритет. В нашем языке программирования он
такой:

Некоторые из этих операторов мы не изучали. Они используются намного реже, но если вы хотите, вы можете их изучить
самостоятельно или спросить меня о деталях.

**()** - скобки

** - степень

**+x, -x, ~x** Унарный плюс, минус и битовое нет

*, /, //, % - Умножить, разделить, разделить без остатка, остаток от деления

**+, -** Сложение и вычитание

**<<, >>** Битовые сдвиги

**&** Битовое и

**^** Битовое исключающее или

**|** Битовое или

**==, !=, >, >=, <, <=, is, is not, in, not in** - сравнения, вхождения итд.

**not** логическое нет

**and** логическое и

**or** логическое или

Если вы не уверены и хотите указать приоритет явно, просто используйте скобки

### Примеры

Любые из этих операций можно комбинировать:

```python
age = int(input('Please enter your age:'))
name = input('Please enter your name:')

age > 18 and 'v' not in name

age < 10 or name == 'Kate'

age // 3 == 1 and len(name) > 4 or str(age) in name
```

## if, elif, else или зачем нам все это вообще нужно

В программировании есть несколько очень базовых концепций, одна из них – это ветвление.

Очень просто: выполнять блок кода только если условие истинно.

В Python для обозначения блоков кода мы используем обычные отступы. Во многих языках программирования для этого
используются различные скобки. У нас используется 4 пробела (на большинстве компьютеров кнопка tab работает именно как 4
пробела).

### if

Сейчас мы рассмотрим ключевые слова **if**, **elif**, **else**, но в Python любые структуры, которые вы будете изучать
дальше,
используют такой же синтаксис с четырьмя пробелами (или одним табом).

```python
a = 100
b = 'bla'
if a:
    print('will be printed')
if a > 50:
    print('will be printed')
if 'c' in b:
    print('wont be printed')
print("will be printed in any case")
```

Когда нам нужно добавить условие, мы просто пишем ключевое слово **if**, после него указываем условие и ставим
двоеточие.
Все, что должно выполняться при выполнении условия, должно быть написано ниже с отступом в 4 пробела. Все, что будет
написано снова на предыдущем уровне, будет выполнено без условий.

### else

Если нам нужно разделить выполнение кода на то, что делать, когда условие выполняется, и что делать, когда нет, мы можем
использовать ключевое слово **else**.

```python
a = 100
if a > 200:
    print('wont be printed')
else:
    print('will be printed')
```

### elif

Также мы можем добавить промежуточные условия, если не выполнится первый if, с помощью elif, который также требует
условия:

Первое условие выполнилось? Нет? Ок, давайте проверим второе, тоже нет? Ну тогда пойдем в **else**

```python
a = 80
if a > 100:
    print('wontbe printed')
elif a > 50:
    print('will be printed')
else:
    print('wont be printed')
```

**elif** можно применять больше одного раза (точнее почти сколько угодно раз)

На самом деле это просто синтаксическое упрощение вот такой конструкции

```python
a = 80
if a > 100:
    print('wontbe printed')
else:
    if a > 50:
        print('will be printed')
    else:
        print('wont be printed')
```

Вы же не думали что вложенность может быть только одного уровня? :)

## match case

Только с версии 3.10 в Python добавили еще одну возможность использовать булевую алгебру. Во многих других языках эта
конструкция называется switch case.

Идея в том, что мы можем задать несколько опций для проверки нашей переменной и выполнить только те, где наша проверка
будет истинной.

```python
status = 400
match status:
    case 400:
        print("Bad request")
    case 401:
        print("Unauthorized")
    case 403:
        print("Forbidden")
    case 404:
        print("Not found")
```

Будет напечатано "Bad request", потому что наша проверка остановится на версии status == 400. Эта конструкция имеет
очень много деталей и тонкостей, если хотите, можете разобрать это самостоятельно, но моя практика показывает, что она
используется редко.

Практика/Домашнее задание:

Задачи 1-5 это одно задание, а 6 это еще одно задание

1) Пользователь задает переменную возраст. Если он старше 18, распечатайте, что все хорошо, если нет, то распечатайте, что
не все хорошо.

2) Добавить к первому условию: если возраст больше 100, распечатать текст, что пользователь вводит нас в заблуждение.

3) Добавить принты, является ли введенный возраст четным или нечетным.

4) Добавить, что пользователь вводит еще и имя. И если в имени есть буква 'a', то написать, что мы даже не собираемся его
проверять.

5) Проверить, если в имени есть буква 'v', большая или маленькая, без разницы. И если возраст пользователя четный, то
написать, что он выиграл приз, если нет, то не выиграл.

6) Спросить у пользователя возраст, пол и имя. Для всех младше 15 мы пишем, что рекомендуем теннис, для мальчиков старше 15
рекомендуем футбол, для девочек - баскетбол, но если в имени есть буква 'c' или 't', пишем, что не рекомендуем
заниматься спортом.